# Rust_Excercise

## 環境とエコシステム
- `rustup`: マルチプレクサ．Rustのツールチェーン(コンパイラ`rustc`，パッケージマネージャ`cargo等`)のバージョン管理を行う．
- `cargo`: ビルドシステム兼パッケージマネージャ．依存関係の解決，コンパイル，テスト，ドキュメント生成を一手に担う．C++における`make`+`cmake`+`conan`+`doxygen`を統合した存在であり，プロジェクトの宣言的定義を可能にする．

## 束縛と不変性
- Rustにおいて`let x = 5`は「代入」ではなく**「束縛(Binding)」**と呼ばれる．
- 数学的な定義x:=5に近く，スコープ内での普遍の事実を宣言する．
- これはデフォルトで「不変（Immutable）」．
- `Default: x -> y`（変更不可）
- `Mutable: let mut x -> v`（変更可能）
- 状態が変わることを特権的な操作として命じさせる（`mut`）ことで，データ競合の発生源を局所化する．
- 何が可変で何が不変なのか，表現したい物自体への理解が必要．いいね．

## インストール
- 公式からrustをインストール
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

- PATHを通す
```bash
source $HOME/.cargo/env
```

## 実行
- ディレクトリ内で以下の`cargo`コマンドを使う
- コンパイルから実行まで
```bash
cargo run
```

- コンパイルのみ
```bash
cargo build
```

- 生成なしの高速構文チェック
```bash
cargo check
```

## 制御構造の式性
- Rustにおいて`if`は制御文ではなく「式」-> 値を返す．
`let y = if x > 5 {10} else {0}`
- この性質により，条件分岐の結果を直接，不変変数に束縛できる．
- 変数をmutにしてあとから条件分岐で代入する必要がない->不変性を維持しやすい

## ループと状態
- `loop`: 無限ループ．明示的に`break`するまで続く．`break value;`で値を返せる．
- `while`: 条件付きループ．
- `for`: イテレータを用いたループ．範囲`0..5`や配列の中身を走査する．

## シャドーイングによる純粋性の模倣
- 物理計算において「時間tの位置x」と「時間t+1の位置x」は，概念上は別の物体である．
- Rustでは**シャドーイング**を用いることで，`mut`を使わずにこれを表現できる．
```rust
let x = 5; // 初期のx
let x = x + 1; // 新しいx（初期のxは隠蔽される）
```

- 「変数の値を書き換える」のではなく，「同じ名前の新しい変数を定義し直す」操作->古いxはアクセス不能だが，不変性の規律は守られる（過去は振り返らない，ぜ）．

## 文と式
- `;`は単なる区切り記号ではない
- 式: 値を返す．例: `y < 0.0`(boolを返す)，`{ 5 }`(5を返す)．
- 文: 値を返さない(ユニット型`()`を返す)．例: `let x = 5;`，`println!...;`. 式の末尾に`;`をつけると，その評価値は捨てられ，式は文に「退化」する．
- `if`文において`;`によって`()`を返してしまい，型不整合が起きた．

## 計算と制御の分離
- 例えば物理エンジンの内部では「衝突した事実」と「シミュレーションを止める判断は」別の関心事．
- `if文`を計算用と制御用で分ける->計算用の方では今の状態のログだけを渡し，制御用の方で，ログに基づいた制御(`break`か`continue`か)をする．

## 所有権の三原則
1. Rustの各値は**所有者（Owner）**と呼ばれる変数と対応している．
2. いかなる時も，所有者は**ただ一人**である．
3. 所有者がスコープ(`{}`)から外れたとき，値は**破棄（Drop）**される．

## Move（移動）とCopy（コピー）
- データサイズが小さく固定された量では，代入時にビット列が自動的に複製される->**Copyトレイト**の実装という．
```rust
let a = 5; let b = a; -> aもbも有効
```

- `String`や配列などのヒープ領域を使うデータは，複製コストが高い->Rustはデフォルトで「所有権の移動（Move）」を行う．
```rust
let s1 = String::from("hello");
let s2 = s1; -> s1は無効化(Invalidated!)
```

- これを**Moveセマンティクス**と呼ぶ．所有権は渡したら手元に残らない．
### パフォーマンスの観点から
- `i32(int)`はstack上のわずか4Byte->コピーするコストが参照(pointer(64bit環境なら8Byte))よりもむしろ安い．
- `String`はheap上の巨大な配列を指す->コピーのたびに $\mathbb{O}(n)$ の計算量が発生し，プログラムは著しく低速化する．

### 整合性
- もし`String`を「ポインタだけコピー(Shallow Copy)」 して，もとの変数を有効なままにしたら？
  - 2つの変数が同じメモリを指す->スコープ終了時に「二重解放(Double Free)」が発生して，メモリ破壊を引き起こす．
  - Rustは「所有者は一人」というルール(Move)によってこのバグを論理的に排除している．

## 参照(Reference)と借用(Borrowing)
- Moveは安全だが，使うたびに所有権を失うのは不便だ->「値を一時的に借りる」仕組み，**参照**と**借用**を導入する．
- `&T`: 不変参照(Immutable Reference)．「見るだけ」の権利．読み取り専用．
- `&mut T`: 可変参照(Mutable Reference)．「書き換える」権利．

### 借用規則(The Rules of Borrowing)
- Rustコンパイラ（Borrow Checker）は，データ競合(Data Race)を防ぐため，以下の規則をコンパイル時に強制する．
1. 任意の数の不変参照`&T`(読者は何人いてもいい)
2. たった1つの可変参照`&mut T`(書き手は一人だけ)
```math
(\any \text{Readers})\rightarrow (\nany \text{Writer})
(\any \text{Writer})\rightarrow (Unique)
```
- 「状態を観測している間(Read)は，状態を変化させてはならない(Write)」->量子力学的な観測問題に似ている．

## 構造体(Structs)
- C言語の`struct`に似ているが，Rustではここに「振る舞い（メソッド）」を後付で実装する点が異なる．

### 構造体: データの集合
- 意味的に関連するデータを一つの型として定義する．
```Rust
struct Particle {
  mass: f64,
  position: f64,
  velocity: f64,
}
```

- これは「データ（設計図）」の定義に過ぎない．

### 実装ブロック(impl): 振る舞いの定義
- データと関数は分離されている．`impl`ブロックを用いて，構造体にメソッドや関連関数を定義する．
```Rust
impl Particle {
  fn new(m: f64, x: f64) -> Particle {
    Particle { mass: m, position: x, velocity: 0.0}
  }
}
```
- メソッド(Method): `self`を第一引数に取る．インスタンスのデータを操作する．
  - `&self`: 読み取りアクセス（不変借用）．
  - `&mut self`: 書き込みアクセス（可変借用）．
  - `self`: 所有権を奪う（消費する）．
- 記法: フィールド初期化省略
  - 変数名とフィールド名が同じ場合，記述を省略できる．`Particle {mass, position, ...}`(`mass: mass`の略)．
- `&self` `&mut self`ともに，所有権を奪うことなく，その中身の変数の読み取りや書き込みに関する権限を付与できる．
- 副作用: 関数が「値を返す(主作用)」以外の働きをすること．
  - 引数以外の変数の書き換え
  - 画面への出力
  - ファイルの保存
  - 計算の外側の世界を変化させる行為を指す
  - `&mut self`を使おう

## 列挙型(Enums): 直和型
- RustのEnumは代数的データ型(Algebraic Data Types)である．単なる定数の羅列ではなく，各バリアントが「異なる種類のデータ」を持つことができる．
```Rust
enum ForceType {
  Gravity, // データなし
  Spring(f64), // バネ定数kを持つ
  Push { x: f64, y: f64 }, // ベクトル成分を持つ（名前付きフィールド）
}
```

- これは「重力かつバネ」ではなく，「重力またはバネまたは押す力」のいずれか一つの状態を取ることを保証する．

## パターンマッチ(match): 網羅性の強制
- `match`式は，Enumのすべての可能性を網羅しなければコンパイルを通さない．
- これにより「想定外の状態」によるバグを論理的に排除する．
```Rust
match force_type {
  ForceType::Gravity => { /* ... */ },
  ForceType::Spring(k) => { /* kを使った計算 */ },
  ForceType::Push { x, y } => { /* x, y を使った計算 */},
}
```

- `if`文の羅列とは異なり，コンパイラが「漏れ」を指摘してくれる．

## ベクトル(ベクタ)
- 「単一の物体」から「多体問題(System)」へ拡張する．ここで主役となるのが`Vec<T>`である．
```Plaintext
Stack (スタック)             Heap (ヒープ)
+--------------+           +---+---+---+---+---+
| ptr      | ●-+---------> | 0 | 1 | 2 | 3 |...| (データ本体)
+--------------+           +---+---+---+---+---+
| len      | 4 |           ↑
+--------------+           ptr
| capacity | 8 |
+--------------+
```

- `Vec<t>` は，スタック上の制御ブロック（3ワード）がヒープ上の実態を所有する構造を持つ
- スコープを抜けるとスタック上の制御ブロックが`Drop`され，連鎖的にヒープ領域も開放される(RAII).

## Option型
- Rustには`null`がない．変わりに`Option<T>`を使う．
- 配列外アクセス`v.get(100`は，プログラムをクラッシュさせるのではなく`None`を返す．
```Rust
let v = vec![10, 20, 30];
// v[100]だとpanic（強制終了）するが...
match v.get(100) {
  Some(x) => println!("Value: {}", x),
  None    => println!("Nothing here"),
}
```

- 「ないかもしれない」という事実は，プログラマに`match`によるハンドリングを強制する->`NullPointerException`は構造的に根絶される．

## クロージャ（無名関数）
- 数学における写像の記法 $f: p\rightarrow (q)$ をプログラムで表現したもの．ラムダ式てきな．
```Rust
self.particles.retain( |p| p.position >= 0.0)
```

- ここで，|p|がクロージャの引数，p.position >= 0.0 がクロージャの本体になる
- `retain`は，ベクトルの全要素に対して，渡された関数を実行し，結果が`true`のものだけを残しそれ以外のものを削除(Drop)する高階関数．

## タプルを使ったfor文
```Rust
for (i, p) in self.particles.iter().enumerate() {
  println!("Particles {}: {}", i, p);
}
```

1. `self.particles`->ベクタ
2. `.iter()`->要素を一つずつ参照(`&Particle`)として取り出すイテレータを作る．
stream: `&Particle A`->`&Particle B`->`&Particle C`
3. `.enumerate()`->イテレータをラップし，現在の「カウント数」を付与した**タプル**を作る．
- `for (i, p)`: `(i, p)` はパターンマッチ(分配束縛)．右辺から流れてくる`(usize, &Particle)`というタプルを分解し，
  - `i`に`0`(index)
  - `p`に`&Particle A`(中身)を代入している．

## ->
- `->`は写像の宣言．関数から何が出てくるかを定義するために使われる．
```Rust
fn function_name(x: X) -> Y { ... }
```

```math
f: X \rightarrow Y
```

- `->`は「入力が処理された結果，この型の値に変換されて出力される」ことをコンパイラと人間に約束する記号．
-

- 数学的アナロジーが多い
```Plaintext
記号   |   名称   |   役割                 |   数学的アナロジー
`->`   |  Arrow   |関数の戻り値の型指定    | 写像f
`:`    |  Colon   |変数やフィールドの型指定|所属x∈A
`=`    |  Equal   |値の束縛(代入じゃない)  |定義x:=a
```


## モジュール
- ファイル分割をしよう
```Plaintext
src/
├── main.rs      (crate root)
├── force.rs     (mod force)
├── particle.rs  (mod particle)
└── world.rs     (mod world)
```

- この配置にするだけでは不十分で，ルート（親）である`main.rs`がモジュールの宣言をしなければならない．
- 可視性の原則
1. デフォルトPrivate: 親モジュールや兄弟モジュールであっても，他人の内部にはアクセスできない．
2. `pub`キーワード: これをつけた項目だけが「親」や「外部」に公開される．
3. 構造体のフィールド: 構造体自体を`pub`にしても，そのフィールドはデフォルトでPrivateである．個別に`pub`が必要．

## テスト
- Rustのテストは関数である．`#[test]`属性をつけることで，それはテストランナーによって認識される．
```Rust
#[cfg(test)] // テスト実行時のみコンパイルされるモジュール
mod tests {
    use super::*; // 親モジュールの中身を全てインポート

    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4); // 等価性の検証
    }
}
```

### アサーション
- `aassert!(condition)`: 条件が`true`であることを期待．
- `assert_eq(a, b)`: `a == b`であることを期待．
- `assert_ne!(a, b)`: `a != b`であることを期待．

